enum SortingDirection {
  ASC
  DESC
}

type Continent @alias(property: "continent") {
  _id: ID! @id
  type: String
  code: String
  desc: String
  airportContainssOut(filter: AirportInput, options: Options, sort: [AirportSort!]): [Airport] @relationship(edgeType: "contains", direction: OUT)
  contains: Contains
}

input ContinentInput {
  _id: ID @id
  type: StringScalarFilters
  code: StringScalarFilters
  desc: StringScalarFilters
}

input ContinentCreateInput {
  _id: ID @id
  type: String
  code: String
  desc: String
}

input ContinentUpdateInput {
  _id: ID! @id
  type: String
  code: String
  desc: String
}

input ContinentSort {
  _id: SortingDirection
  type: SortingDirection
  code: SortingDirection
  desc: SortingDirection
}

type Country @alias(property: "country") {
  _id: ID! @id
  type: String
  code: String
  desc: String
  foundingDate: AWSDate
  localOfficeTime: AWSTime
  updatedAt: AWSDateTime
  createdTimestamp: AWSTimestamp
  officialEmail: AWSEmail
  metadataJson: AWSJSON
  governmentSite: AWSURL
  emergencyLine: AWSPhone
  gatewayIp: AWSIPAddress
  airportContainssOut(filter: AirportInput, options: Options, sort: [AirportSort!]): [Airport] @relationship(edgeType: "contains", direction: OUT)
  contains: Contains
}

input CountryInput {
  _id: ID @id
  type: StringScalarFilters
  code: StringScalarFilters
  desc: StringScalarFilters
  foundingDate: AWSDate
  localOfficeTime: AWSTime
  updatedAt: AWSDateTime
  createdTimestamp: AWSTimestamp
  officialEmail: AWSEmail
  metadataJson: AWSJSON
  governmentSite: AWSURL
  emergencyLine: AWSPhone
  gatewayIp: AWSIPAddress
}

input CountryCreateInput {
  _id: ID @id
  type: String
  code: String
  desc: String
  foundingDate: AWSDate
  localOfficeTime: AWSTime
  updatedAt: AWSDateTime
  createdTimestamp: AWSTimestamp
  officialEmail: AWSEmail
  metadataJson: AWSJSON
  governmentSite: AWSURL
  emergencyLine: AWSPhone
  gatewayIp: AWSIPAddress
}

input CountryUpdateInput {
  _id: ID! @id
  type: String
  code: String
  desc: String
  foundingDate: AWSDate
  localOfficeTime: AWSTime
  updatedAt: AWSDateTime
  createdTimestamp: AWSTimestamp
  officialEmail: AWSEmail
  metadataJson: AWSJSON
  governmentSite: AWSURL
  emergencyLine: AWSPhone
  gatewayIp: AWSIPAddress
}

input CountrySort {
  _id: SortingDirection
  type: SortingDirection
  code: SortingDirection
  desc: SortingDirection
  foundingDate: SortingDirection
  localOfficeTime: SortingDirection
  updatedAt: SortingDirection
  createdTimestamp: SortingDirection
  officialEmail: SortingDirection
  metadataJson: SortingDirection
  governmentSite: SortingDirection
  emergencyLine: SortingDirection
  gatewayIp: SortingDirection
}

type Version @alias(property: "version") {
  _id: ID! @id
  date: String
  desc: String
  author: String
  type: String
  code: String
  dataSourcePulled_cn_fromOut(filter: DataSourceInput, options: Options): [DataSource] @relationship(edgeType: "pulled:From", direction: OUT)
  pulled_cn_From: Pulled_cn_from
}

input VersionInput {
  _id: ID @id
  date: StringScalarFilters
  desc: StringScalarFilters
  author: StringScalarFilters
  type: StringScalarFilters
  code: StringScalarFilters
}

input VersionCreateInput {
  _id: ID @id
  date: String
  desc: String
  author: String
  type: String
  code: String
}

input VersionUpdateInput {
  _id: ID! @id
  date: String
  desc: String
  author: String
  type: String
  code: String
}

input VersionSort {
  _id: SortingDirection
  date: SortingDirection
  desc: SortingDirection
  author: SortingDirection
  type: SortingDirection
  code: SortingDirection
}

type Airport @alias(property: "airport") {
  _id: ID! @id
  type: String
  city: String
  icao: String
  code: String
  country: String
  lat: Float
  longest: Int
  runways: Int
  desc: String
  lon: Float
  region: String
  elev: Int
  outboundRoutesCount: Int @graphQuery(statement: "MATCH (this)-[r:route]->(a) RETURN count(r)")
  continentContainsIn: Continent @relationship(edgeType:"contains", direction:IN)
  countryContainsIn: Country @relationship(edgeType:"contains", direction:IN)
  airportRoutesOut(filter: AirportInput, options: Options): [Airport] @relationship(edgeType:"route", direction:OUT)
  airportRoutesIn(filter: AirportInput, options: Options): [Airport] @relationship(edgeType:"route", direction:IN)
  contains:Contains
  route:Route
}

input AirportInput {
  _id: ID @id
  type: StringScalarFilters
  city: StringScalarFilters
  icao: StringScalarFilters
  code: StringScalarFilters
  country: StringScalarFilters
  lat: Float
  longest: Int
  runways: Int
  desc: StringScalarFilters
  lon: Float
  region: StringScalarFilters
  elev: Int
}

input AirportCreateInput {
  _id: ID @id
  type: String
  city: String
  icao: String
  code: String
  country: String
  lat: Float
  longest: Int
  runways: Int
  desc: String
  lon: Float
  region: String
  elev: Int
}

input AirportUpdateInput {
  _id: ID! @id
  type: String
  city: String
  icao: String
  code: String
  country: String
  lat: Float
  longest: Int
  runways: Int
  desc: String
  lon: Float
  region: String
  elev: Int
}

input AirportSort {
  _id: SortingDirection
  type: SortingDirection
  city: SortingDirection
  icao: SortingDirection
  code: SortingDirection
  country: SortingDirection
  lat: SortingDirection
  longest: SortingDirection
  runways: SortingDirection
  desc: SortingDirection
  lon: SortingDirection
  region: SortingDirection
  elev: SortingDirection
}

type DataSource @alias(property: "dataSource") {
  _id: ID! @id
  name: String
  type: String
  url: String
  description: String
  lastUpdated: String
  isActive: Boolean
  versionPulled_cn_fromsIn(filter: VersionInput, options: Options, sort: [VersionSort!]): [Version] @relationship(edgeType: "pulled:From", direction: IN)
  pulled_cn_From: Pulled_cn_from
}

input DataSourceInput {
  _id: ID @id
  name: StringScalarFilters
  type: StringScalarFilters
  url: StringScalarFilters
  description: StringScalarFilters
  lastUpdated: StringScalarFilters
  isActive: Boolean
}

input DataSourceCreateInput {
  _id: ID @id
  name: String
  type: String
  url: String
  description: String
  lastUpdated: String
  isActive: Boolean
}

input DataSourceUpdateInput {
  _id: ID! @id
  name: String
  type: String
  url: String
  description: String
  lastUpdated: String
  isActive: Boolean
}

input DataSourceSort {
  _id: SortingDirection
  name: SortingDirection
  type: SortingDirection
  url: SortingDirection
  description: SortingDirection
  lastUpdated: SortingDirection
  isActive: SortingDirection
}

type Contains @alias(property: "contains") {
  _id: ID! @id
}

type Route @alias(property: "route") {
  _id: ID! @id
  dist: Int
}

input RouteInput {
  dist: Int
}

type Pulled_cn_from @alias(property: "pulled:From") {
  _id: ID! @id
}

input Options {
  limit: Int
  offset: Int
}

input StringScalarFilters {
  eq: String
  contains: String
  endsWith: String
  startsWith: String
}

type Query {
  getAirportByCode(code: String): Airport
  getAirportConnection(fromCode: String!, toCode: String!): Airport @cypher(statement: "MATCH (:airport{code: '$fromCode'})-[:route]->(this:airport)-[:route]->(:airport{code:'$toCode'})")
  getContinentsWithGremlin: [Continent] @graphQuery(statement: "g.V().hasLabel('continent').elementMap().fold()")
  getCountriesCountGremlin: Int @graphQuery(statement: "g.V().hasLabel('country').count()")
  getContinent(filter: ContinentInput): Continent
  getContinents(filter: ContinentInput, options: Options, sort: [ContinentSort!]): [Continent]
  getCountry(filter: CountryInput): Country
  getCountrys(filter: CountryInput, options: Options, sort: [CountrySort!]): [Country]
  getVersion(filter: VersionInput): Version
  getVersions(filter: VersionInput, options: Options, sort: [VersionSort!]): [Version]
  getAirport(filter: AirportInput): Airport
  airportQuery_getAirport(filter: AirportInput): Airport
  getAirports(filter: AirportInput, options: Options, sort: [AirportSort!]): [Airport]
  getAirportWithGremlin(code: String): Airport @graphQuery(statement: "g.V().has('airport', 'code', '$code').elementMap()")
  getCountriesCount: Int @graphQuery(statement: "g.V().hasLabel('country').count()")
}

type Mutation {
  createAirport(input: AirportCreateInput!): Airport
  airportMutation_createAirport(input: AirportCreateInput!): Airport
  updateAirport(input: AirportUpdateInput!): Airport
  airportMutation_updateAirport(input: AirportUpdateInput!): Airport
  connectCountryToAirportThroughContains(from_id: ID!, to_id: ID!): Contains
  airportMutation_connectCountryToAirportThroughContains(from_id: ID!, to_id: ID!): Contains
  deleteContainsConnectionFromCountryToAirport(from_id: ID!, to_id: ID!): Boolean
  airportMutation_deleteContainsConnectionFromCountryToAirport(from_id: ID!, to_id: ID!): Boolean
  updateRouteConnectionFromAirportToAirport(from_id: ID!, to_id: ID!, edge: RouteInput!): Route
  airportMutation_updateRouteConnectionFromAirportToAirport(from_id: ID!, to_id: ID!, edge: RouteInput!): Route
  connectVersionToDataSourceThroughPulled_cn_from(from_id: ID!, to_id: ID!): Pulled_cn_from
  deletePulled_cn_fromConnectionFromVersionToDataSource(from_id: ID!, to_id: ID!): Boolean
  createAirportCustom(input: AirportCreateInput!): Airport @graphQuery(statement: "CREATE (this:airport {$input}) RETURN this")
}

schema {
  query: Query
  mutation: Mutation
}